from pathlib import Path


def run(context: dict[str, str]) -> None:
    """
    Patch TagSet to be a valid Pydantic RootModel.
    The generator creates an empty class because of the non-standard format 'string<Tag>[]'.
    """
    out_dir = Path(context["out_dir"])
    file_path = out_dir / "camunda_orchestration_sdk" / "models" / "tag_set.py"
    
    if not file_path.exists():
        print(f"Warning: {file_path} does not exist, skipping patch.")
        return

    print(f"Patching {file_path} to be a valid Pydantic RootModel...")
    
    # We replace the entire file content with a valid implementation
    new_content = """# coding: utf-8

\"\"\"
    Orchestration Cluster API

    API for communicating with a Camunda 8 cluster.

    The version of the OpenAPI document: 0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
\"\"\"  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import RootModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Self

class TagSet(RootModel[List[str]]):
    \"\"\"
    List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.
    \"\"\" # noqa: E501
    root: List[str] = Field(description="List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.")

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        \"\"\"Returns the string representation of the model using alias\"\"\"
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        \"\"\"Returns the JSON representation of the model using alias\"\"\"
        return self.model_dump_json(by_alias=True, exclude_unset=True)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        \"\"\"Create an instance of TagSet from a JSON string\"\"\"
        return cls.model_validate_json(json_str)

    def to_dict(self) -> Any:
        \"\"\"Return the dictionary representation of the model using alias.
        \"\"\"
        return self.model_dump(by_alias=True, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: Any) -> Optional[Self]:
        \"\"\"Create an instance of TagSet from a dict\"\"\"
        if obj is None:
            return None

        if not isinstance(obj, list):
            return cls.model_validate(obj)

        return cls.model_validate(obj)
"""
    
    file_path.write_text(new_content, encoding="utf-8")
    print("Successfully patched TagSet.")
